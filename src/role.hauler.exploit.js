var utilities = require('utilities');

Creep.prototype.setExploitHaulerTargetSource = function () {
    var exploit = Game.exploits[this.memory.exploitName];

    if (exploit.memory.lairs) {
        if (!this.memory.currentLair || !exploit.memory.lairs[this.memory.currentLair]) {
            this.memory.currentLair = exploit.memory.closestLairToEntrance;
        }

        for (let id in exploit.memory.lairs) {
            if (!exploit.memory.lairs[id].source) continue;

            let source = Game.getObjectById(exploit.memory.lairs[id].source);
            if (!source) continue;

            let container = source.getNearbyContainer();
            // @todo Calculate threshhold when to collect resources.
            if (container && _.sum(container.store) >= 500) {
                // Check if other haulers are going for this already.
                let haulers = this.room.creepsByRole['hauler.exploit'];
                var found = 0;
                for (let i in haulers) {
                    let hauler = haulers[i];
                    if (hauler.id == this.id) continue;

                    if (hauler.memory.pickupResources && hauler.memory.currentLair == id) {
                        found++;
                    }
                }

                if (found == 0 || (found == 1 && _.sum(container.store) >= 1200)) {
                    // Plot a path to the target lair.
                    if (this.memory.currentLair != id) {
                        let path = exploit.memory.lairs[this.memory.currentLair].paths[id];
                        if (path) {
                            if (path.path) {
                                this.setCachedPath(exploit.memory.lairs[this.memory.currentLair].paths[id].path, false, 3);
                            }
                            else {
                                this.setCachedPath(exploit.memory.lairs[id].paths[this.memory.currentLair].path, true, 3);
                            }
                        }
                        this.memory.currentLair = id;
                    }
                    this.memory.pickupResources = true;
                    return;
                }
            }
        }

        // Seems like no source has enough energy yet.
        // Travel to a random active one so we don't clump up at the entrance.
        let id = _.sample(_.filter(_.keys(exploit.memory.lairs), (id) => {
            let lair = exploit.memory.lairs[id];
            let source = Game.getObjectById(lair.source);
            if (source) {
                return true;
            }
        }));
        let path = exploit.memory.lairs[this.memory.currentLair].paths[id];
        if (path) {
            if (path.path) {
                this.setCachedPath(exploit.memory.lairs[this.memory.currentLair].paths[id].path, false, 3);
            }
            else {
                this.setCachedPath(exploit.memory.lairs[id].paths[this.memory.currentLair].path, true, 3);
            }
            this.memory.currentLair = id;
            this.memory.pickupResources = true;
        }
    }
};

/**
 * Makes the creep gather resources in the current room.
 */
Creep.prototype.performExploitCollect = function () {
    var creep = this;

    // Always pick up nearby resources.
    var dropped = this.pos.findInRange(FIND_DROPPED_RESOURCE, 1, {
        filter: (resource) => resource.resourceType == RESOURCE_ENERGY
    });
    if (dropped.length > 0) {
        this.pickup(dropped[0]);
    }

    var exploit = Game.exploits[this.memory.exploitName];
    if (exploit) {
        // Follow cached path when requested.
        if (this.hasCachedPath()) {
            this.followCachedPath();
            if (this.hasArrived()) {
                this.clearCachedPath();

                if (this.memory.travellingToRoom) {
                    // Next, find and travel to destined source.
                    if (exploit.memory.closestLairToEntrance) {
                        this.memory.currentLair = exploit.memory.closestLairToEntrance;
                    }
                    else if (exploit.memory.lairs) {
                        for (let id in exploit.memory.lairs) {
                            this.memory.currentLair = id;
                            break;
                        }
                    }
                    this.setExploitHaulerTargetSource();
                    delete this.memory.travellingToRoom;
                }

            }
            else {
                return true;
            }
        }
        else if (this.pos.roomName != exploit.roomName && exploit.memory.pathToRoom) {
            this.setCachedPath(exploit.memory.pathToRoom, false, 1);
            this.memory.travellingToRoom = true;
            delete this.memory.currentLair;
            return true;
        }
        else {
            if (this.memory.pickupResources) {
                let source = Game.getObjectById(exploit.memory.lairs[this.memory.currentLair].source);
                let container = source.getNearbyContainer();
                if (!container) {
                    let resources = this.pos.findInRange(FIND_DROPPED_RESOURCE, 3, {
                        filter: (resource) => resource.resourceType == RESOURCE_ENERGY
                    });
                    if (resources.length <= 0) {
                        delete this.memory.pickupResources;
                        return true;
                    }
                    //console.log(resources.length);
                    if (this.pos.getRangeTo(resources[0]) > 1) {
                        this.moveToRange(resources[0], 1);
                    }
                    else {
                        this.pickup(resources[0]);
                    }
                    return true;
                }

                if (this.pos.getRangeTo(container) > 1) {
                    this.moveTo(container);
                }
                else {
                    if (_.sum(container.store) > 0) {
                        for (let resourceType in container.store) {
                            if (container.store[resourceType] > 0) {
                                this.withdraw(container, resourceType);
                                break;
                            }
                        }
                    }
                    else {
                        delete this.memory.pickupResources;
                    }
                }
            }
            else {
                // Set target source.
                this.setExploitHaulerTargetSource();
            }
        }
    }

    return true;
};

/**
 * Dumps minerals a harvester creep has gathered.
 */
Creep.prototype.performExploitHaulerDeliver = function () {
    var creep = this;
    var exploit = Game.exploits[this.memory.exploitName];
    if (exploit) {
        // Follow cached path when requested.
        if (this.hasCachedPath()) {
            this.followCachedPath();
            if (this.hasArrived()) {
                this.clearCachedPath();
                this.memory.travellingToRoom = false;
            }
            else {
                return true;
            }
        }
        else if (this.pos.roomName == exploit.roomName && exploit.memory.pathToRoom) {
            // @todo Make sure we've moved to the entrance lair first.
            if (this.memory.currentLair && this.memory.currentLair != exploit.memory.closestLairToEntrance) {
                if (exploit.memory.lairs[this.memory.currentLair].paths[exploit.memory.closestLairToEntrance]) {
                    if (exploit.memory.lairs[this.memory.currentLair].paths[exploit.memory.closestLairToEntrance].path) {
                        this.setCachedPath(exploit.memory.lairs[this.memory.currentLair].paths[exploit.memory.closestLairToEntrance].path, false, 3);
                    }
                    else {
                        this.setCachedPath(exploit.memory.lairs[exploit.memory.closestLairToEntrance].paths[this.memory.currentLair].path, true, 3);
                    }
                    this.memory.currentLair = exploit.memory.closestLairToEntrance;
                    return true;
                }
            }

            this.setCachedPath(exploit.memory.pathToRoom, true, 3);
            this.memory.travellingToRoom = true;
            delete this.memory.currentLair;
            return true;
        }
        else {
            let resourceType;
            let amount;
            for (let type in this.carry) {
                if (!resourceType || this.carry[type] > amount) {
                    amount = this.carry[type];
                    resourceType = type;
                }
            }

            var target = this.room.getBestStorageTarget(amount, resourceType);
            if (this.pos.getRangeTo(target) > 1) {
                this.moveToRange(target, 1);
            }
            else {
                this.transferAny(target);
            }
        }
    }


    return true;
};

/**
 * Puts this creep into or out of harvesting mode.
 */
Creep.prototype.setExploitHaulerState = function (harvesting) {
    this.memory.harvesting = harvesting;
    delete this.memory.resourceTarget;
    delete this.memory.tempRole;
    delete this.memory.pickupResources;
};

/**
 * Makes a creep behave like an exploit harvester.
 */
Creep.prototype.runExploitHaulerLogic = function () {
    if (!this.memory.harvesting && _.sum(this.carry) <= 0) {
        this.setExploitHaulerState(true);
    }
    else if (this.memory.harvesting && _.sum(this.carry) >= this.carryCapacity * 0.9) {
        this.setExploitHaulerState(false);
    }

    if (this.memory.harvesting) {
        return this.performExploitCollect();
    }
    else {
        return this.performExploitHaulerDeliver();
    }
};
